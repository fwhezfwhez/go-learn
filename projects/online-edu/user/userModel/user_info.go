package userModel

import (
	"encoding/json"
	"fmt"
	"github.com/fwhezfwhez/errorx"
	"github.com/garyburd/redigo/redis"
	"github.com/jinzhu/gorm"
	"io/ioutil"
	"net/http"
	"time"
)

// Auto-Generate Header
/*
   Code is auto-generated by github.com/fwhezfwhez/model_convert.Package below might be imported:
     - github.com/fwhezfwhez/errorx
     - github.com/garyburd/redigo/redis
     - github.com/jinzhu/gorm
   You can get them by:
     - go get github.com/fwhezfwhez/errorx
     - go get github.com/garyburd/redigo/redis
     - go get github.com/jinzhu/gorm

   To fulfill redis part, don't forget to set TODOs.They are:
     - RedisKey() string
     - RedisSecondDuration() int
*/
type UserInfo struct {
	Id        int             `gorm:"column:id;default:" json:"id" form:"id"`
	Username  string          `gorm:"column:username;default:" json:"username" form:"username"`
	Realname  string          `gorm:"column:realname;default:" json:"realname" form:"realname"`
	Age       int             `gorm:"column:age;default:" json:"age" form:"age"`
	Raw       json.RawMessage `gorm:"column:raw;default:" json:"raw" form:"raw"`
	CreatedAt time.Time       `gorm:"column:created_at;default:" json:"created_at" form:"created_at"`
}

func (o UserInfo) TableName() string {
	return "user_info"
}

func (o UserInfo) RedisKey() string {
	// TODO set its redis key
	return ""
}

func (o UserInfo) ArrayRedisKey() string {
	// TODO set its array key
	return ""
}

func (o UserInfo) RedisSecondDuration() int {
	// TODO set its redis duration, default 1-7 day,  return -1 means no time limit
	return int(time.Now().Unix()%7+1) * 24 * 60 * 60
}

// TODO,set using db or not. If set false, o.MustGet() will never get its data from db.
func (o UserInfo) UseDB() bool {
	return false
}

func (o *UserInfo) GetFromRedis(conn redis.Conn) error {
	if o.RedisKey() == "" {
		return errorx.NewFromString("object UserInfo has not set redis key yet")
	}
	buf, e := redis.Bytes(conn.Do("GET", o.RedisKey()))

	if e == nil && string(buf) == "DISABLE" {
		return fmt.Errorf("not found record in db nor redis")
	}

	if e == redis.ErrNil {
		return e
	}

	if e != nil && e != redis.ErrNil {
		return errorx.Wrap(e)
	}

	e = json.Unmarshal(buf, &o)

	if e != nil {
		return errorx.Wrap(e)
	}
	return nil
}

func (o *UserInfo) ArrayGetFromRedis(conn redis.Conn) ([]UserInfo, error) {
	if o.ArrayRedisKey() == "" {
		return nil, errorx.NewFromString("object UserInfo has not set redis key yet")
	}

	var list = make([]UserInfo, 0, 10)
	buf, e := redis.Bytes(conn.Do("GET", o.ArrayRedisKey()))

	// avoid passing through and hit database
	// When o.ArrayMustGet() not found both in redis and db, will set its key DISABLE
	// and return 'fmt.Errorf("not found record in db nor redis")'
	if e == nil && string(buf) == "DISABLE" {
		return nil, fmt.Errorf("not found record in db nor redis")
	}

	// Not found in redis
	if e == redis.ErrNil {
		return nil, e
	}

	// Server error, should be logged by caller
	if e != nil && e != redis.ErrNil {
		return nil, errorx.Wrap(e)
	}

	e = json.Unmarshal(buf, &list)

	if e != nil {
		return nil, errorx.Wrap(e)
	}
	return list, nil
}

// engine should prepare its condition.
// if record not found,it will return 'var notFound = fmt.Errorf("not found record in db nor redis")'.
// If you want to ignore not found error, do it like:
// if e:= o.MustGet(conn, engine.Model(Model{}).Where("condition =?", arg)).Error;e!=nil {
//     if e.Error() == "not found record in db nor redis"{
//         log.Println(e)
//         return
//     }
// }
func (o *UserInfo) MustGet(conn redis.Conn, engine *gorm.DB) error {
	e := o.GetFromRedis(conn)
	// When redis key stores its value 'DISABLE', will returns notFoundError and no need to query from db any more
	if e != nil && e.Error() == "not found record in db nor redis" {
		return e
	}

	if e == nil {
		return nil
	}
	if e != nil {
		var count int
		if e2 := engine.Count(&count).Error; e2 != nil {
			return errorx.GroupErrors(errorx.Wrap(e), errorx.Wrap(e2))
		}
		if count == 0 {
			var notFound = fmt.Errorf("not found record in db nor redis")
			if o.RedisSecondDuration() == -1 {
				conn.Do("SET", o.RedisKey(), "DISABLE", "NX")
			} else {
				conn.Do("SET", o.RedisKey(), "DISABLE", "EX", o.RedisSecondDuration(), "NX")
			}
			return notFound
		}

		if e3 := engine.First(&o).Error; e3 != nil {
			return errorx.GroupErrors(errorx.Wrap(e), errorx.Wrap(e3))
		}
		if e == redis.ErrNil {
			o.SyncToRedis(conn)
			return nil
		}
		return errorx.Wrap(e)
	}
	return nil
}

func (o *UserInfo) ArrayMustGet(conn redis.Conn, engine *gorm.DB) ([]UserInfo, error) {
	list, e := o.ArrayGetFromRedis(conn)
	// When redis key stores its value 'DISABLE', will returns notFoundError and no need to query from db any more
	// When call ArrayDeleteFromRedis(), will activate its redis and db query
	if e != nil && e.Error() == "not found record in db nor redis" {
		return nil, e
	}
	// get from redis success.
	if e == nil {
		return list, nil
	}
	// get from redis fail, try db
	if e != nil {
		var count int
		if e2 := engine.Count(&count).Error; e2 != nil {
			return nil, errorx.GroupErrors(errorx.Wrap(e), errorx.Wrap(e2))
		}
		if count == 0 {
			var notFound = fmt.Errorf("not found record in db nor redis")
			if o.RedisSecondDuration() == -1 {
				conn.Do("SET", o.ArrayRedisKey(), "DISABLE", "NX")
			} else {
				conn.Do("SET", o.ArrayRedisKey(), "DISABLE", "EX", o.RedisSecondDuration(), "NX")
			}
			return nil, notFound
		}

		if e3 := engine.Find(&list).Error; e3 != nil {
			return nil, errorx.GroupErrors(errorx.Wrap(e), errorx.Wrap(e3))
		}
		// try sync to redis
		if e == redis.ErrNil {
			o.ArraySyncToRedis(conn, list)
			return list, nil
		}
		return nil, errorx.Wrap(e)
	}
	return nil, nil
}

func (o UserInfo) SyncToRedis(conn redis.Conn) error {
	if o.RedisKey() == "" {
		return errorx.NewFromString("object UserInfo has not set redis key yet")
	}
	buf, e := json.Marshal(o)
	if e != nil {
		return errorx.Wrap(e)
	}
	if o.RedisSecondDuration() == -1 {
		if _, e := conn.Do("SET", o.RedisKey(), buf); e != nil {
			return errorx.Wrap(e)
		}
	} else {
		if _, e := conn.Do("SETEX", o.RedisKey(), o.RedisSecondDuration(), buf); e != nil {
			return errorx.Wrap(e)
		}
	}
	return nil
}

func (o UserInfo) ArraySyncToRedis(conn redis.Conn, list []UserInfo) error {
	if o.ArrayRedisKey() == "" {
		return errorx.NewFromString("object UserInfo has not set redis key yet")
	}
	buf, e := json.Marshal(list)
	if e != nil {
		return errorx.Wrap(e)
	}
	if o.RedisSecondDuration() == -1 {
		if _, e := conn.Do("SET", o.ArrayRedisKey(), buf); e != nil {
			return errorx.Wrap(e)
		}
	} else {
		if _, e := conn.Do("SETEX", o.ArrayRedisKey(), o.RedisSecondDuration(), buf); e != nil {
			return errorx.Wrap(e)
		}
	}
	return nil
}

func (o UserInfo) DeleteFromRedis(conn redis.Conn) error {
	if o.RedisKey() != "" {
		if _, e := conn.Do("DEL", o.RedisKey()); e != nil {
			return errorx.Wrap(e)
		}
	}

	if o.ArrayRedisKey() != "" {
		if _, e := conn.Do("DEL", o.ArrayRedisKey()); e != nil {
			return errorx.Wrap(e)
		}
	}

	return nil
}
func (o UserInfo) ArrayDeleteFromRedis(conn redis.Conn) error {
	return o.DeleteFromRedis(conn)
}

// Dump data through api GET remote url generated by 'GenerateListApi()' to local database.
// This method should never used in production. It's best to to run it before app is running.
//
// mode=1, each time will delete old local data and dump from api.
// mode=2, each time will update/keep the existed data. Mode=2 is developing.
func (o UserInfo) DumpToLocal(url string, engine *gorm.DB, mode int) error {
	tableName := o.TableName()

	tran := engine.Begin()
	if e := tran.Exec(fmt.Sprintf("delete from %s", tableName)).Error; e != nil {
		tran.Rollback()
		return errorx.Wrap(e)
	}

	type Result struct {
		Data  []UserInfo `json:"data"`
		Count int        `json:"count"`
	}
	var result Result
	resp, e := http.Get(url)
	if e != nil {
		tran.Rollback()
		return errorx.Wrap(e)
	}
	if resp == nil || resp.Body == nil {
		tran.Rollback()
		return errorx.NewFromString("resp or body nil")
	}
	defer resp.Body.Close()

	buf, e := ioutil.ReadAll(resp.Body)
	if e != nil {
		tran.Rollback()
		return errorx.Wrap(e)
	}

	if resp.StatusCode != 200 {
		var body string
		if len(buf) < 100 {
			body = string(buf)
		} else {
			body = string(buf[:100])
		}
		return errorx.NewFromStringf("status not 200, got %d,body %s", resp.StatusCode, body)
	}

	if e := json.Unmarshal(buf, &result); e != nil {
		tran.Rollback()
		return errorx.Wrap(e)
	}

	for i, _ := range result.Data {
		data := result.Data[i]
		if e := tran.Model(&o).Create(&data).Error; e != nil {
			tran.Rollback()
			return errorx.Wrap(e)
		}
	}
	tran.Commit()
	return nil
}

// Auto-Generate Tail
